#!/usr/bin/env bash

sourceable_script='false'

if [[ "$sourceable_script" != 'true' && ! "${BASH_SOURCE[0]}" -ef "$0" ]]
then
    echo "Do not source this script! Execute it with bash instead."
    return 1
fi
unset sourceable_script

########################
### Library sourcing ###
########################

library_sourcing()
{
    # Unset as only called once and most likely overwritten when sourcing libs
    unset -f library_sourcing

    local -r THIS_SCRIPT_PATH="$(tmp_find_script_path)"

    # Store $THIS_SCRIPT_PATH as unique or local variables
    # LIB_PATH is needed by sourced libraries as well
    readonly PROJECT_BASE_PATH="$THIS_SCRIPT_PATH"
    export PROJECT_BASE_PATH
    readonly LIB_PATH="$THIS_SCRIPT_PATH/lib"
    export LIB_PATH

    ### Source libraries ###
    source "$LIB_PATH/lib_core.bash"
    source "$LIB_PATH/lib_handle_input.bash"
}

# Minimal version of find_path(). Should only be used within this script to source library defining find_path().
tmp_find_script_path() {
    unset -f tmp_find_script_path; local s="${BASH_SOURCE[0]}"; local d
    while [ -L "$s" ]; do d=$(cd -P "$(dirname "$s")" &>/dev/null && pwd); s=$(readlink "$s"); [[ $s != /* ]] && s=$d/$s; done
    echo "$(cd -P "$(dirname "$s")" &>/dev/null && pwd)"
}

library_sourcing

############
### MAIN ###
############

COLOR_RED='\033[0;31m'
COLOR_GREEN='\033[0;32m'
COLOR_YELLOW='\033[0;33m'
COLOR_BLUE='\033[0;34m'
COLOR_END='\033[0m'

main()
{
    _handle_args_main "$@"
    # Output:
    # - base_dir (Optional)

    local tmpdir=$(mktemp -d)

    local processes_id=()
    local processes_name=()
    local processes_done=()
    for found in $(find "$base_dir" \( -type d -o -type f \) -name ".git")
    do
        if [[ -f "$found" ]]
        then
            # .git indicates this is a Git Submodule
            [[ "$exclude_submodule_flag" == 'true' ]] && continue
        else
            # .git indicates this is a normal Git Repository
            :
        fi

        sanitized_name=$(sanitize_filename "$found")
        check_git_status "$found" "$tmpdir/$sanitized_name" </dev/null  &
        processes_id+=( "$!" )
        processes_name+=( "$found" )
        processes_done+=( 'false' )
    done

    local num_processes_done=0
    local num_total_processes=${#processes_id[@]}
    echo -e "\nRepositories checked:"
    local indicator_counter=0
    local num_processes_done=0
    while ((num_processes_done != num_total_processes ))
    do
        local indicator
        case $((indicator_counter++)) in
            1)
                indicator='/'
                ;;
            2)
                indicator='-'
                ;;
            3)
                indicator='\'
                ;;
            4)
                indicator='|'
                indicator_counter=0
                ;;
        esac

        # -n and \r to replace line
        echo -ne "***** [$indicator] $num_processes_done/$num_total_processes *****\r"

        ###
        # Check if processes are done
        local all_processes_done='true'
        for i in "${!processes_done[@]}"
        do
            if [[ "${processes_done[i]}" != 'true' ]]
            then # Process is not done previous iteration check
                # Check if process is done now
                if ! kill -0 ${processes_id[i]} 2>/dev/null
                then
                    processes_done[i]='true'
                    ((num_processes_done++))
                else
                    # Not done
                    all_processes_done='false'
                fi
            fi
        done

        [[ "$all_processes_done" == 'true' ]] && break

        sleep 0.1
    done
    echo -ne "***** $num_processes_done/$num_total_processes *****    \r"
    echo

    local num_output_files="$(ls -1 "$tmpdir" | wc -l)"

    if (( num_output_files != 0 ))
    then
        # Output everythings from background jobs
        if [[ "$verbose_flag" == 'true' ]]
        then
            cat "$tmpdir"/*
        else
            for file in "$tmpdir"/*
            do
                if (( $(wc -l < "$file") > 0 ))
                then
                    echo
                    cat "$file"
                fi
            done
        fi
    fi

    rm -rf "$tmpdir"
}

###################
### END OF MAIN ###
###################

register_help_text 'git status-recursive' \
'git status-recursive [flags] [DIR]

Used for finding out the git status of multiple repositories recursively down from the
current or specified directory.

[DIR] (Optional): Directory to run recursively down the directory structure from'

register_function_flags 'git status-recursive' \
                        '-v' '--verbose' 'false' \
                        "Verbose file status" \
                        '' '--no-fetch' 'false' \
                        "Don't fetch before checking repository status" \
                        '-p' '--prune' 'false' \
                        "Prune while fetching. E.g. removes upstream deleted branches" \
                        '-c' '--only-current-branch' 'false' \
                        "Only check the currently checked out branch" \
                        '-f' '--only-file-changes' 'false' \
                        "Only check for file changes" \
                        '' '--on-track' 'false' \
                        "Show branches which are on track" \
                        '' '--exclude-no-news' 'false' \
                        "Don't print repositories which got nothing new to update about." \
                        '' '--exclude-submodule' 'false' \
                        "Don't check the status of git submodules" \
                        '' '--exclude-no-local' 'false' \
                        "Don't check for remote branches which aren't available locally" \
                        '' '--exclude-no-remote' 'false' \
                        "Don't check for local branches which aren't available on the remote" \
                        '' '--exclude-deleted-remote' 'false' \
                        "Don't check for local branches which have had their remote branch deleted"

_handle_args_main()
{
    _handle_args 'git status-recursive' "$@"

    define help_text << END_OF_FUNCTION_USAGE
Usage: git status-recursive [ DIR ]
    DIR: (Optional)
        * Directory to recursively check down from.
END_OF_FUNCTION_USAGE

    ###
    # Non-flagged arguments
    if (( ${#non_flagged_args[@]} != 0 ))
    then
        main_input_dir=${non_flagged_args[0]}
        if ! [[ -d "$main_input_dir" ]]
        then
            define error_info << END_OF_ERROR_INFO
Given [ DIR ] is not a directory: '$main_input_dir'
END_OF_ERROR_INFO
            invalid_function_usage 2 "$help_text" "$error_info"
            exit 1
        fi
    fi

    [[ -n "$main_input_dir" ]] && base_dir="$main_input_dir" || base_dir='.' 

    ###
    # -h, --help
    if [[ "$help_flag" == 'true' ]]
    then
        echo "$help_text"
        exit 0
    fi

    ###
    # -v, --verbose
    if [[ "$verbose_flag" == 'true' ]]
    then
        :
    fi

    ###
    # --no-fetch
    if [[ "$no_fetch_flag" == 'true' ]]
    then
        :
    fi

    ###
    # -p, --prune
    if [[ "$prune_flag" == 'true' ]]
    then
        :
    fi

    ###
    # -c, --only-current-branch
    if [[ "$only_current_branch_flag" == 'true' ]]
    then
        :
    fi

    ###
    # -c, --only-file-changes
    if [[ "$only_file_changes_flag" == 'true' ]]
    then
        :
    fi

    ###
    # --on-track
    if [[ "$on_track_flag" == 'true' ]]
    then
        show_on_track='true'
    fi

    ###
    # --exclude-no-news
    if [[ "$exclude_no_news_flag" == 'true' ]]
    then
        :
    fi

    ###
    # --exclude-submodule
    if [[ "$exclude_submodule_flag" == 'true' ]]
    then
        :
    fi

    ###
    # --exclude-no-local
    if [[ "$exclude_no_local_flag" == 'true' ]]
    then
        :
    fi


    ###
    # --exclude-no-remote
    if [[ "$exclude_no_remote_flag" == 'true' ]]
    then
        :
    fi

    ###
    # --exclude-deleted-remote
    if [[ "$exclude_deleted_remote_flag" == 'true' ]]
    then
        :
    fi
}

colorize()
{
    while IFS= read -r line; do
        echo -e "${1}${line}${COLOR_END}"
    done
}

sanitize_filename()
{
    local new_name
    [[ "$1" == "./.git" ]] && new_name="$(pwd)" || new_name="$1"

    # Remove potential /.git suffix, strip leading ./ from the path, and replace / with _
    new_name=$(echo "$new_name" | sed 's/\/\.git$//' | sed 's/^.\///' | sed 's/\//__/g')
    echo "$new_name"
}

convert_porcelain_status()
{
    local status_indicator="$1"

    local plus="${COLOR_GREEN}+${COLOR_END}"
    local asterix="${COLOR_RED}*${COLOR_END}"
    local percentage="${COLOR_RED}%${COLOR_END}"

    case "$status_indicator" in
        ' M'|' T'|' D')
            # Unstaged changes
            echo -e "${asterix} "
            ;;
        'M '|'A '|'R '|'C ')
            # Staged changes
            echo -e "${plus} "
            ;;
        'MM'|'MT'|'MD'|'AM'|'AD'|'RM'|'CM'|'TM'|'TD')
            # Staged and modified in worktree
            echo -e "${plus}${asterix}"
            ;;
        '??')
            # Untracked files
            echo -e "${percentage}"
            ;;
        'UU'|'DD'|'AU'|'UD'|'UA'|'DU'|'AA')
            # Unmerged states
            echo -e "${COLOR_RED}MERGE${COLOR_END}"
            ;;
        '  ')
            # Unmodified
            echo '  ';;
        '!!')
            # Ignored files
            echo '  '
            ;;
        *)
            # Any other state not handled
            echo -e "${COLOR_RED}UNKOWN${COLOR_END}"
            ;;
    esac

    return 0
}

convert_porcelain_status_verbose()
{
    local status_indicator="$1"

    local index_indicator="${status_indicator:0:1}"
    local worktree_indicator="${status_indicator:1:1}"

    [[ -z "$index_indicator" ]] && [[ -z "$worktree_indicator" ]] && return 1

    if [[ "$status_indicator" == '??' ]]
    then
        echo -e "${COLOR_RED}[[      UNTRACKED      ]]${COLOR_END}"
        return 0
    fi

    local output=""
    local change
    local color
    for indicator in "$index_indicator" "$worktree_indicator"
    do
        [[ "$indicator" == "$worktree_indicator" ]] && color="$COLOR_RED"
        [[ "$indicator" == "$index_indicator" ]] && color="$COLOR_GREEN"

        case "$indicator" in
            'M')
                change='true'
                output+="${color}[ CHANGED  ]${COLOR_END}" ;;
            'A')
                change='true'
                output+="${color}[  ADDED   ]${COLOR_END}" ;;
            'D')
                change='true'
                output+="${color}[ DELETED  ]${COLOR_END}" ;;
            'R')
                change='true'
                output+="${color}[ RENAMED  ]${COLOR_END}" ;;
            'C')
                change='true'
                output+="${color}[ COPIED   ]${COLOR_END}" ;;
            'U')
                change='true'
                output+="${color}[ UNMERGED ]${COLOR_END}" ;;
            ' ')
                output+='[    --    ]'
                change='false'
                ;;
            *)
                change='true'
                output+="${COLOR_RED}[ UNKNOWN  ]${COLOR_END}" ;;
        esac
    done

    echo -e "$output"
}

index_working_tree_status()
{
    local porcelain_status=$(git status --porcelain)

    if [[ -z "$porcelain_status" ]]
    then
        [[ "$verbose_flag" == 'true' ]] && echo -e "\n[NO CHANGES]"
        return 0
    fi
    [[ "$verbose_flag" == 'true' ]] && echo
    [[ "$verbose_flag" == 'true' ]] && echo "[  Index   ][ Worktree ] <File>"

    while IFS= read -r line # <<< "$porcelain_status"
    do
        local status_indicator="${line:0:2}"
        local index_indicator="${status_indicator:0:1}"
        local worktree_indicator="${status_indicator:1:1}"
        local file="${line:3}"

        local converted_indicators
        if [[ "$verbose_flag" == 'true' ]]
        then
            converted_indicators=$(convert_porcelain_status_verbose "$status_indicator")
        else
            converted_indicators=$(convert_porcelain_status "$status_indicator")
        fi

        echo "${converted_indicators} ${file}"

    done <<< "$porcelain_status"
}

# Excludes current branch in output
git_ahead_behind_status_branches()
{
    local current_branch=$(git rev-parse --abbrev-ref HEAD)

    array_local_branch=()
    array_remote_name=()
    array_remote_branch=()
    array_num_ahead_remote=()
    array_num_behind_remote=()

    local local_branch remote track
    
    array_output_branch_on_track=()
    array_output_branch_no_remote=()
    array_output_branch_deleted_remote=()
    array_output_ahead_behind=()
    local branches_info=$(git for-each-ref --format="%(refname:short) %(upstream:short) %(upstream:track)" refs/heads)
    while IFS=" " read -r local_branch remote track # <<< "$branches_info"
    do
        array_local_branch+=("$local_branch")

        local remote_name="${remote%%/*}"
        local remote_branch="${remote#*/}"

        local num_ahead_remote=0
        local num_behind_remote=0
        if [[ "$track" == '[gone]' ]]
        then
            num_ahead_remote='_'
            num_behind_remote='_'
            remote_branch='[gone]'
        elif [[ -n "$track" ]]
        then
            num_ahead_remote="$(grep -Po '(?<=ahead )\d+' <<< "$track")"
            num_behind_remote="$(grep -Po '(?<=behind )\d+' <<< "$track")"
        fi

        array_remote_name+=("$remote_name")
        array_remote_branch+=("$remote_branch")

        array_num_ahead_remote+=($num_ahead_remote)
        array_num_behind_remote+=($num_behind_remote)

        [[ "$local_branch" == "$current_branch" ]] && continue

        format_ahead_behind_status_branch "$local_branch" \
                                          "$remote_name" \
                                          "$remote_branch" \
                                          "$num_ahead_remote" \
                                          "$num_behind_remote"

        case "$formatted_output" in
            *'[ON TRACK]'*)
                array_output_branch_on_track+=("$formatted_output")
                ;;
            *'[NO REMOTE]'*)
                array_output_branch_no_remote+=("$formatted_output")
                ;;
            *'[DELETED REMOTE]'*)
                array_output_branch_deleted_remote+=("$formatted_output")
                ;;
            *)
                array_output_ahead_behind+=("$formatted_output")
                ;;
        esac

    done <<< "$branches_info"
}

# Output in variable 'formatted_output'
format_ahead_behind_status_branch()
{
    local local_branch="$1"
    local remote_name="$2"
    local remote_branch="$3"
    local num_ahead_remote="$4"
    local num_behind_remote="$5" 

    if [[ -z "$remote_branch" ]]
    then # No remote
        formatted_output="${COLOR_RED}[NO REMOTE]${COLOR_END} $local_branch"
        return
    fi

    if [[ "$remote_branch" == '[gone]' ]]
    then
        formatted_output="${COLOR_RED}[DELETED REMOTE]${COLOR_END} $local_branch"
        return
    fi

    if (( num_ahead_remote == 0 && num_behind_remote == 0 ))
    then # On track with remote
        formatted_output="[ON TRACK] $local_branch"
        return
    fi

    # Not on track with remote
    local output_ahead output_behind
    if [[ "$verbose_flag" == 'true' ]]
    then
        output_ahead="[${num_ahead_remote} AHEAD]"
        output_behind="[${num_behind_remote} BEHIND]"
    else
        output_ahead="[${num_ahead_remote}>]"
        output_behind="[<${num_behind_remote}]"
    fi

    (( num_ahead_remote != 0 )) && output_ahead="${COLOR_RED}${output_ahead}${COLOR_END}"
    (( num_behind_remote != 0 )) && output_behind="${COLOR_YELLOW}${output_behind}${COLOR_END}"

    formatted_output="${output_ahead}${output_behind} $local_branch -> $remote_name/$remote_branch"
}

git_check_no_local_branches()
{
    array_output_branch_no_local=()

    # For every remote branch
    for remote_branch in $(git for-each-ref --format '%(refname:short)' refs/remotes)
    do
        [[ "$remote_branch" == */HEAD ]] && continue

        # Check if any local branch tracks the current remote branch
        local_branch=$(git for-each-ref --format '%(refname:short) %(upstream:short)' refs/heads/ | grep "$remote_branch$"  | cut -d' ' -f1)

        if [ -z "$local_branch" ]
        then
            array_output_branch_no_local+=("${COLOR_YELLOW}[NO LOCAL]${COLOR_END} $remote_branch")
        fi
    done
}

print_branches_on_track()
{
    print_array -e "${array_output_branch_on_track[@]}"
}

print_branches_no_remote()
{
    print_array -e "${array_output_branch_no_remote[@]}"
}

print_branches_no_local()
{
    print_array -e "${array_output_branch_no_local[@]}"
}

print_branches_remote_deleted()
{
    print_array -e "${array_output_branch_deleted_remote[@]}"
}

print_branches_ahead_behind()
{
    print_array -e "${array_output_ahead_behind[@]}"
}

register_help_text 'print_array' \
'print_array [flags] <array>

Output the array elements one by one with a new line per element.

<array>: Array elements given with ${array_name[@]}'

register_function_flags 'print_array' \
                        '-e' '' 'false' \
                        "Corresponding echo '-e' flag. Enables interpretation of backslash escapes."

print_array()
{
    _handle_args_print_array "$@"
    local array=("${non_flagged_args[@]}")

    [[ -z "${array[@]}" ]] && return 1

    local flags=""
    [[ "$e_flag_print_array" == 'true' ]] && flags='-e'

    for element in "${array[@]}"
    do
        echo $flags "$element"
    done

    return 0
}

_handle_args_print_array()
{
    _handle_args 'print_array' "$@"

    if [[ "$e_flag" == 'true' ]]
    then
        e_flag_print_array='true'
    fi
}

check_git_status()
{
    local dir="$1"
    local outfile="$2"

    # Open file descriptor 3 for writing to the output file
    exec 3>>"$outfile"
    # Redirect stdout to fd 3 (output file)
    exec 1> >(colorize '' >&3)
    # Redirect stderr to the colorize function, and then to fd 3 (output file)
    exec 2> >(colorize "$COLOR_RED" >&3)

    repo_dir="${dir%/.git}"

    pushd "$repo_dir" >/dev/null || return
    
    [[ "$(dirname "$dir")" == '.' ]] && repo_dir="./$(basename $(pwd))"

    local all_output=""
    
    [[ "$prune_flag" == 'true' ]] && local extra_fetch_flags='--prune'
    [[ "$no_fetch_flag" != 'true' ]] && git fetch --all $extra_fetch_flags &> /dev/null

    git_ahead_behind_status_branches

    if [[ "$only_current_branch_flag" != 'true' ]] && \
       [[ "$only_file_changes_flag" != 'true' ]]
    then
        git_check_no_local_branches

        local output_branches=""

        if [[ "$show_on_track" == 'true' ]]
        then
            output_branches+=$(print_branches_on_track) && output_branches+='\n'
        fi

        if [[ "$exclude_deleted_remote_flag" == 'true' ]]
        then
            output_branches+=$(print_branches_remote_deleted) && output_branches+='\n'
        fi

        if [[ "$exclude_no_remote_flag" == 'true' ]]
        then
            output_branches+=$(print_branches_no_remote) && output_branches+='\n'
        fi

        if [[ "$exclude_no_local_flag" == 'true' ]]
        then
            output_branches+=$(print_branches_no_local) && output_branches+='\n'
        fi

        output_branches+=$(print_branches_ahead_behind)

        if [[ -n "$output_branches" ]]
        then
            all_output+="Other branches:\n${output_branches}"
        fi
    fi

    local output_current_branch=""
    local current_branch=$(git rev-parse --abbrev-ref HEAD)

    if [[ "$only_file_changes_flag" != 'true' ]]
    then
        local index
        local in_branch='false'

        for index in ${!array_local_branch[@]}
        do
            if [[ "${array_local_branch[index]}" == "$current_branch" ]]
            then
                in_branch='true'
                break
            fi
        done

        # If not found, 'current_branch' is probably HEAD
        if [[ "$in_branch" == 'true' ]]
        then
            format_ahead_behind_status_branch "$current_branch" \
                                            "${array_remote_name[index]}" \
                                            "${array_remote_branch[index]}" \
                                            "${array_num_ahead_remote[index]}" \
                                            "${array_num_behind_remote[index]}"

            if ! ( [[ "$verbose_flag" != 'true' ]] && [[ "$formatted_output" == *'[ON TRACK]'* ]] )
            then
                output_current_branch+="$formatted_output"
            fi
        fi
    fi

    output_current_branch+=$(index_working_tree_status)

    if [[ -n "$output_current_branch" ]]
    then
        [[ -n "$output_branches" ]] && all_output+="\n\n"
        all_output+="Current branch: ${current_branch}\n"
        all_output+="${output_current_branch}"
    elif [[ "$in_branch" != 'true' ]]
    then
        all_output+="Current branch: ${current_branch}"
        [[ "$current_branch" == 'HEAD' ]] && all_output+=" (Detached state)"
        all_output+="\n"
    fi

    if [[ -n "$all_output" ]]
    then
        [[ "$verbose_flag" == 'true' ]] && echo
        echo "${COLOR_BLUE}======================== Repo: $repo_dir ========================${COLOR_END}"
        echo "$all_output"
    else
        if [[ "$exclude_no_news_flag" != 'true' ]]
        then
            [[ "$verbose_flag" == 'true' ]] && echo
            echo -e "${COLOR_BLUE}======================== Repo: $repo_dir ========================${COLOR_END}"
        fi
    fi

    popd >/dev/null

    exec 1>/dev/tty
    exec 2>/dev/tty
}

main_stderr_red()
{
    main "$@" 2> >(sed $'s|.*|\e[31m&\e[m|' >&2)
}

#################
### Call main ###
#################
main_stderr_red "$@"
#################
