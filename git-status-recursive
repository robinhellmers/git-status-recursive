#!/usr/bin/env bash

sourceable_script='false'

if [[ "$sourceable_script" != 'true' && ! "${BASH_SOURCE[0]}" -ef "$0" ]]
then
    echo "Do not source this script! Execute it with bash instead."
    return 1
fi
unset sourceable_script

########################
### Library sourcing ###
########################

library_sourcing()
{
    # Unset as only called once and most likely overwritten when sourcing libs
    unset -f library_sourcing

    local -r THIS_SCRIPT_PATH="$(tmp_find_script_path)"

    # Store $THIS_SCRIPT_PATH as unique or local variables
    # LIB_PATH is needed by sourced libraries as well
    readonly PROJECT_BASE_PATH="$THIS_SCRIPT_PATH"
    export PROJECT_BASE_PATH
    readonly LIB_PATH="$THIS_SCRIPT_PATH/lib"
    export LIB_PATH

    ### Source libraries ###
    source "$LIB_PATH/lib_core.bash"
    source "$LIB_PATH/lib_handle_input.bash"
}

# Minimal version of find_path(). Should only be used within this script to source library defining find_path().
tmp_find_script_path() {
    unset -f tmp_find_script_path; local s="${BASH_SOURCE[0]}"; local d
    while [ -L "$s" ]; do d=$(cd -P "$(dirname "$s")" &>/dev/null && pwd); s=$(readlink "$s"); [[ $s != /* ]] && s=$d/$s; done
    echo "$(cd -P "$(dirname "$s")" &>/dev/null && pwd)"
}

library_sourcing

############
### MAIN ###
############

COLOR_RED='\033[0;31m'
COLOR_YELLOW='\033[0;33m'
COLOR_BLUE='\033[0;34m'
COLOR_END='\033[0m'

main()
{
    _handle_args_main "$@"
    # Output:
    # - base_dir (Optional)

    local tmpdir=$(mktemp -d)

    local processes=()
    local processes_name=()
    for found in $(find "$base_dir" \( -type d -o -type f \) -name ".git")
    do
        if [[ -f "$found" ]]
        then
            # .git indicates this is a Git Submodule
            [[ "$exclude_submodule_flag" == 'true' ]] && continue
        else
            # .git indicates this is a normal Git Repository
            :
        fi

        sanitized_name=$(sanitize_filename "$found")
        check_git_status "$found" "$tmpdir/$sanitized_name" </dev/null  &
        processes+=( "$!" )
        processes_name+=( "$found" )
    done

    local num_processes_done=0
    local num_total_processes=${#processes[@]}
    echo -e "\nRepositories checked:"
    local i=0
    while ((num_processes_done != num_total_processes ))
    do
        local indicator
        case $((i++)) in
            1)
                indicator='/'
                ;;
            2)
                indicator='-'
                ;;
            3)
                indicator='\'
                ;;
            4)
                indicator='|'
                i=0
                ;;
        esac
        num_processes_done=$(find "$tmpdir" -type f -name "*.done" | wc -l)
        # -n and \r to replace line
        echo -ne "***** [$indicator] $num_processes_done/$num_total_processes *****\r"
        sleep 0.1
    done
    echo -ne "***** $num_processes_done/$num_total_processes *****    \r"
    echo

    wait "${processes[@]}"

    # Output everythings from background jobs
    if $minimal_out
    then
        for file in "$tmpdir"/*
        do
            if (( $(wc -l < "$file") > 3 ))
            then
                echo
                cat "$file"
            fi
        done
    else
        cat "$tmpdir"/*
    fi

    rm -rf "$tmpdir"
}

###################
### END OF MAIN ###
###################

register_function_flags 'git status-recursive' \
                        '-h' '--help' 'false' \
                        "Print help text" \
                        '-m' '--minimal' 'false' \
                        "Minimal output" \
                        '' '--exclude-submodule' 'false' \
                        "Don't check the status of git submodules" \
                        '' '--no-fetch' 'false' \
                        "Don't fetch before checking repository status"
_handle_args_main()
{
    _handle_args 'git status-recursive' "$@"

    define help_text << END_OF_FUNCTION_USAGE
Usage: git status-recursive [ DIR ]
    DIR: (Optional)
        * Directory to recursively check down from.
END_OF_FUNCTION_USAGE

    ###
    # Non-flagged arguments
    if (( ${#non_flagged_args[@]} != 0 ))
    then
        main_input_dir=${non_flagged_args[0]}
        if ! [[ -d "$main_input_dir" ]]
        then
            define error_info << END_OF_ERROR_INFO
Given [ DIR ] is not a directory: '$main_input_dir'
END_OF_ERROR_INFO
            invalid_function_usage 2 "$help_text" "$error_info"
            exit 1
        fi
    fi

    [[ -n "$main_input_dir" ]] && base_dir="$main_input_dir" || base_dir='.' 

    ###
    # -h, --help
    if [[ "$help_flag" == 'true' ]]
    then
        echo "$help_text"
        exit 0
    fi

    ###
    # -m, --minimal
    minimal_out=false
    if [[ "$minimal_flag" == 'true' ]]
    then
        main_minimal_flag='true'
        minimal_out=true
    fi

    ##
    # --exclude-submodule
    if [[ "$exclude_submodule_flag" == 'true' ]]
    then
        :
    fi

    ##
    # --no-fetch
    if [[ "$no_fetch_flag" == 'true' ]]
    then
        :
    fi
}

sanitize_filename()
{
    local new_name
    [[ "$1" == "./.git" ]] && new_name="$(pwd)" || new_name="$1"

    # Remove potential /.git suffix, strip leading ./ from the path, and replace / with _
    new_name=$(echo "$new_name" | sed 's/\/\.git$//' | sed 's/^.\///' | sed 's/\//__/g')
    echo "$new_name"
}

convert_porcelain_status() {
    local index_indicator="$1"
    local worktree_indicator="$2"

    [[ -z "$index_indicator" ]] && [[ -z "$worktree_indicator" ]] && return 1

    if [[ "$index_indicator" == '?' && "$worktree_indicator" == '?' ]]
    then
        if $minimal_out
        then
            echo -e "${COLOR_RED}MODIFIED FILE${COLOR_END}"
        else
            echo -e "${COLOR_RED}[[      UNTRACKED      ]]${COLOR_END}"
        fi

        return 0
    fi

    local output=""
    local change
    for indicator in "$index_indicator" "$worktree_indicator"
    do
        case "$indicator" in
            'M')
                change='true'
                output+="${COLOR_RED}[ CHANGED  ]${COLOR_END}" ;;
            'A')
                change='true'
                output+="${COLOR_RED}[ ADDED    ]${COLOR_END}" ;;
            'D')
                change='true'
                output+="${COLOR_RED}[ DELETED  ]${COLOR_END}" ;;
            'R')
                change='true'
                output+="${COLOR_RED}[ RENAMED  ]${COLOR_END}" ;;
            'C')
                change='true'
                output+="${COLOR_RED}[ COPIED   ]${COLOR_END}" ;;
            'U')
                change='true'
                output+="${COLOR_RED}[ UNMERGED ]${COLOR_END}" ;;
            ' ')
                output+="[     -     ]"
                change='false'
                ;;
            *)
                change='true'
                output+="${COLOR_RED}[ UNKNOWN  ]${COLOR_END}" ;;
        esac
    done

    if $minimal_out && [[ "$change" == 'true' ]]
    then
        output="${COLOR_RED}MODIFIED FILE${COLOR_END}"
    fi
    echo -e "$output"
}

index_working_tree_status()
{
    local porcelain_status=$(git status --porcelain)

    if [[ -z "$porcelain_status" ]]
    then
        $minimal_out || echo -e "\n[NO CHANGES]"
        return 0
    fi
    $minimal_out || echo
    $minimal_out || echo "[   Index   ][ Worktree ] <File>"

    while IFS= read -r line # <<< "$porcelain_status"
    do
        local index_indicator="${line:0:1}"
        local worktree_indicator="${line:1:1}"
        local file="${line:3}"

        local converted_indicators=$(convert_porcelain_status "$index_indicator" \
                                                            "$worktree_indicator")

        echo "${converted_indicators} ${file}"

    done <<< "$porcelain_status"

    # $minimal_out && echo
}

# Excludes current branch in output
git_ahead_behind_status_branches()
{
    local current_branch=$(git rev-parse --abbrev-ref HEAD)

    array_local_branch=()
    array_remote_name=()
    array_remote_branch=()
    array_num_ahead_remote=()
    array_num_behind_remote=()

    local local_branch remote track
    
    array_output_branch_on_track=()
    array_output_branch_no_remote=()
    array_output_ahead_behind=()
    local branches_info=$(git for-each-ref --format="%(refname:short) %(upstream:short) %(upstream:track)" refs/heads)
    while IFS=" " read -r local_branch remote track # <<< "$branches_info"
    do
        array_local_branch+=("$local_branch")

        local remote_name="${remote%%/*}"
        local remote_branch="${remote#*/}"
        array_remote_name+=("$remote_name")
        array_remote_branch+=("$remote_branch")

        local num_ahead_remote="$(grep -Po '(?<=ahead )\d+' <<< "$track")"
        local num_behind_remote="$(grep -Po '(?<=behind )\d+' <<< "$track")"
        [[ -z "$num_ahead_remote" ]] && num_ahead_remote=0
        [[ -z "$num_behind_remote" ]] && num_behind_remote=0
        array_num_ahead_remote+=($num_ahead_remote)
        array_num_behind_remote+=($num_behind_remote)

        [[ "$local_branch" == "$current_branch" ]] && continue

        format_ahead_behind_status_branch "$local_branch" \
                                          "$remote_name" \
                                          "$remote_branch" \
                                          "$num_ahead_remote" \
                                          "$num_behind_remote"

        case "$formatted_output" in
            *'[ON TRACK]'*)
                array_output_branch_on_track+=("$formatted_output")
                ;;
            *'[NO REMOTE]'*)
                array_output_branch_no_remote+=("$formatted_output")
                ;;
            *)
                array_output_ahead_behind+=("$formatted_output")
                ;;
        esac

    done <<< "$branches_info"
}

# Output in variable 'formatted_output'
format_ahead_behind_status_branch()
{
    local local_branch="$1"
    local remote_name="$2"
    local remote_branch="$3"
    local num_ahead_remote="$4"
    local num_behind_remote="$5" 

    if [[ -z "$remote_branch" ]]
    then # No remote
        formatted_output="${COLOR_RED}[NO REMOTE]${COLOR_END} $local_branch"
        return
    fi

    if (( num_ahead_remote == 0 && num_behind_remote == 0 ))
    then # On track with remote
        formatted_output="[ON TRACK] $local_branch"
        return
    fi

    # Not on track with remote
    local output_ahead output_behind
    if $minimal_out
    then
        output_ahead="[${num_ahead_remote}>]"
        output_behind="[<${num_behind_remote}]"
    else
        output_ahead="[${num_ahead_remote} AHEAD]"
        output_behind="[${num_behind_remote} BEHIND]"
    fi

    (( num_ahead_remote != 0 )) && output_ahead="${COLOR_RED}${output_ahead}${COLOR_END}"
    (( num_behind_remote != 0 )) && output_behind="${COLOR_YELLOW}${output_behind}${COLOR_END}"

    formatted_output="${output_ahead}${output_behind} $local_branch -> $remote_name/$remote_branch"
}

git_check_no_local_branches()
{
    array_output_branch_no_local=()

    # For every remote branch
    for remote_branch in $(git for-each-ref --format '%(refname:short)' refs/remotes)
    do
        [[ "$remote_branch" == */HEAD ]] && continue

        # Check if any local branch tracks the current remote branch
        local_branch=$(git for-each-ref --format '%(refname:short) %(upstream:short)' refs/heads/ | grep "$remote_branch$"  | cut -d' ' -f1)

        if [ -z "$local_branch" ]
        then
            array_output_branch_no_local+=("${COLOR_YELLOW}[NO LOCAL]${COLOR_END} $remote_branch")
        fi
    done
}

print_branches_on_track()
{
    print_array -e "${array_output_branch_on_track[@]}"
}

print_branches_no_remote()
{
    print_array -e "${array_output_branch_no_remote[@]}"
}

print_branches_no_local()
{
    print_array -e "${array_output_branch_no_local[@]}"
}

print_branches_ahead_behind()
{
    print_array -e "${array_output_ahead_behind[@]}"
}

register_function_flags 'print_array' \
                        '-e' '' 'false' \
                        "Corresponding echo '-e' flag. Enables interpretation of backslash escapes."

print_array()
{
    _handle_args_print_array "$@"
    local array=("${non_flagged_args[@]}")

    local flags=""
    [[ "$e_flag_print_array" == 'true' ]] && flags='-e'

    for element in "${array[@]}"
    do
        echo $flags "$element"
    done
}

_handle_args_print_array()
{
    _handle_args 'print_array' "$@"

    if [[ "$e_flag" == 'true' ]]
    then
        e_flag_print_array='true'
    fi
}

check_git_status()
{
    local dir="$1"
    local outfile="$2"

    exec 1>"$outfile"
    exec 2>>"$outfile"

    repo_dir="${dir%/.git}"

    pushd "$repo_dir" >/dev/null || return
    
    [[ "$(dirname "$dir")" == '.' ]] && repo_dir="./$(basename $(pwd))"

    $minimal_out || echo
    echo -e "${COLOR_BLUE}======================== Repo: $repo_dir ========================${COLOR_END}"
    
    [[ "$no_fetch_flag" != 'true' ]] && git fetch --all &> /dev/null

    git_ahead_behind_status_branches
    git_check_no_local_branches

    $minimal_out || echo
    $minimal_out || echo "*** Check branches ***"
    $minimal_out || echo

    $minimal_out || print_branches_on_track
    print_branches_no_remote
    print_branches_no_local
    print_branches_ahead_behind

    $minimal_out || echo
    $minimal_out || echo "*** Check current branch ***"
    $minimal_out || echo
    local index
    local found='true'
    local current_branch=$(git rev-parse --abbrev-ref HEAD)
    for index in ${!array_local_branch[@]}
    do
        [[ "${array_local_branch[index]}" == "$current_branch" ]] && break
    done

    format_ahead_behind_status_branch "$current_branch" \
                                      "${array_remote_name[index]}" \
                                      "${array_remote_branch[index]}" \
                                      "${array_num_ahead_remote[index]}" \
                                      "${array_num_behind_remote[index]}"

    $minimal_out && echo -e "\nCurrent branch: $current_branch"

    if ! ( $minimal_out && [[ "$formatted_output" == *'[ON TRACK]'* ]] )
    then
        echo -e "$formatted_output"
    fi

    index_working_tree_status

    touch "$outfile.done" &> /dev/null
    popd >/dev/null

    exec 1>/dev/tty
    exec 2>/dev/tty
}

main_stderr_red()
{
    main "$@" 2> >(sed $'s|.*|\e[31m&\e[m|' >&2)
}

#################
### Call main ###
#################
main_stderr_red "$@"
#################
